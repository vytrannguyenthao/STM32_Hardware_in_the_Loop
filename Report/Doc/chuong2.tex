\chapter{LÝ THUYẾT}
\section{Hệ thống mô phỏng phần cứng trong vòng lặp}
Hardware-in-the-Loop (HIL) là một phương pháp kiểm thử hệ thống, trong đó một phần phần cứng thực của hệ thống nhúng – thường là thiết bị cần kiểm thử (Device Under Test – DUT) – được kết nối và vận hành trong một môi trường mô phỏng. Môi trường mô phỏng này có nhiệm vụ tái hiện hành vi của các thành phần bên ngoài hệ thống, bao gồm cảm biến, cơ cấu chấp hành, hoặc các thiết bị ngoại vi giao tiếp với DUT.

Khác với các phương pháp mô phỏng thuần phần mềm, HIL cho phép kiểm thử trực tiếp firmware chạy trên phần cứng thực, trong khi các thành phần còn lại của hệ thống được thay thế bằng mô hình mô phỏng. Nhờ đó, HIL giúp đánh giá chính xác hơn hành vi của hệ thống nhúng trong các điều kiện vận hành gần với thực tế, đồng thời giảm phụ thuộc vào phần cứng hoàn chỉnh trong giai đoạn phát triển ban đầu.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{image/hil.png}
    \caption{Hệ thống mô phỏng phần cứng trong vòng lặp}
    \label{fig:hil}
\end{figure}

Nguyên lý hoạt động của hệ thống HIL dựa trên một vòng lặp khép kín giữa phần cứng thực và môi trường mô phỏng. Trong vòng lặp này, DUT thực thi firmware và trao đổi tín hiệu với hệ thống mô phỏng thông qua các giao diện phần cứng.

Cụ thể, môi trường mô phỏng sẽ tạo ra các tín hiệu đầu vào hoặc dữ liệu giao tiếp như tín hiệu cảm biến, dữ liệu I2C, SPI, UART và gửi tới DUT. DUT xử lý các dữ liệu này theo thuật toán đã lập trình và tạo ra các tín hiệu đầu ra hoặc phản hồi. Các tín hiệu đầu ra của DUT sau đó được hệ thống HIL thu nhận, phân tích và sử dụng để cập nhật trạng thái của mô hình mô phỏng, từ đó tạo ra các tín hiệu đầu vào tiếp theo cho DUT.

Quá trình trao đổi này diễn ra liên tục theo thời gian thực hoặc gần thời gian thực, tạo thành một vòng lặp tương tác giữa phần cứng và mô phỏng. Nhờ nguyên lý này, HIL cho phép kiểm thử các kịch bản phức tạp, các tình huống lỗi và các điều kiện biên mà việc kiểm thử trên hệ thống thực gặp nhiều khó khăn hoặc rủi ro.

\section{Các giao thức giao tiếp ngoại vi trong hệ thống mô phỏng}
\subsection{Giao thức UART}
UART (Universal Asynchronous Receiver Transmitter) là giao thức truyền thông nối tiếp không đồng bộ, sử dụng hai đường tín hiệu chính là TX (Transmit) và RX (Receive). Không giống như các giao thức đồng bộ, UART không sử dụng xung clock chung mà thay vào đó hai thiết bị phải thống nhất trước các tham số truyền thông như tốc độ truyền nhận, số bit dữ liệu, bit kiểm tra chẵn lẻ và bit dừng.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{image/uart.png}
    \caption{Giao thức UART}
    \label{fig:uart}
\end{figure}

Nguyên lý hoạt động của UART dựa trên việc truyền dữ liệu theo từng khung. Mỗi khung dữ liệu bao gồm một bit bắt đầu, các bit dữ liệu, bit kiểm tra (nếu có) và bit kết thúc. Thiết bị nhận sẽ sử dụng tốc độ truyền nhận đã cấu hình để lấy mẫu tín hiệu và khôi phục dữ liệu ban đầu.

Trong hệ thống mô phỏng phần cứng trong vòng lặp này, UART thường được sử dụng để mô phỏng các thiết bị giao tiếp nối tiếp bên ngoài và phục vụ mục đích debug.
\subsection{Giao thức I2C}
I2C (Inter-Integrated Circuit) là giao thức truyền thông nối tiếp đồng bộ, sử dụng hai đường tín hiệu SDA (Serial Data) và SCL (Serial Clock). Bus I2C hoạt động theo cơ chế master–slave, trong đó thiết bị master tạo xung clock và điều khiển quá trình truyền thông, còn các thiết bị slave phản hồi dựa trên địa chỉ được gửi.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{image/i2c.png}
    \caption{Giao thức I2C}
    \label{fig:i2c}
\end{figure}

Quá trình truyền dữ liệu trên bus I2C bắt đầu bằng điều kiện START, sau đó master gửi địa chỉ của thiết bị slave kèm theo bit chỉ định hướng truyền (đọc hoặc ghi). Thiết bị có địa chỉ trùng khớp sẽ phản hồi bằng tín hiệu ACK, cho phép master tiếp tục truyền dữ liệu. Kết thúc phiên giao tiếp, master phát điều kiện STOP để giải phóng bus.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{image/i2c_data_frame.png}
    \caption{Khung dữ liệu I2C}
    \label{fig:i2c_data_frame}
\end{figure}

Một đặc điểm quan trọng của I2C là khả năng hỗ trợ nhiều thiết bị slave trên cùng một bus nhờ cơ chế địa chỉ. Mỗi slave được định danh bằng một địa chỉ riêng, do đó master có thể giao tiếp với nhiều thiết bị mà không cần thêm đường tín hiệu vật lý.

Tuy nhiên, vi điều khiển được lựa chọn để thực hiện mô phỏng I2C có thể bị giới hạn về mặt phần cứng, chẳng hạn chỉ hỗ trợ tối đa một hoặc hai địa chỉ slave I2C thông qua ngoại vi phần cứng tích hợp. Trong khi đó, theo đặc tả giao thức I2C, số lượng thiết bị slave có thể tồn tại trên cùng một bus là lớn hơn nhiều, miễn là mỗi thiết bị có địa chỉ riêng biệt và không trùng lặp.

Để khắc phục hạn chế về số lượng slave phần cứng, một giải pháp thường được nhắc đến là sử dụng kỹ thuật bit-banging, trong đó các tín hiệu SDA và SCL được điều khiển hoàn toàn bằng phần mềm thông qua các chân GPIO. Phương pháp này cho phép mô phỏng linh hoạt nhiều thiết bị I2C và không phụ thuộc vào ngoại vi I2C phần cứng của vi điều khiển.

Tuy nhiên, việc sử dụng bit-banging tồn tại nhiều hạn chế. Do quá trình tạo xung clock và điều khiển dữ liệu được thực hiện bằng phần mềm, độ chính xác về thời gian phụ thuộc lớn vào tốc độ xử lý và khả năng đáp ứng ngắt của hệ thống. Điều này có thể dẫn đến sai lệch thời gian, đặc biệt khi hệ thống HIL phải đồng thời xử lý nhiều tác vụ mô phỏng khác. Ngoài ra, bit-banging làm tăng tải cho CPU, ảnh hưởng đến tính thời gian thực và độ ổn định của toàn bộ hệ thống mô phỏng.

Mặt khác, trên một bus I2C, tại một thời điểm chỉ tồn tại một phiên giao tiếp duy nhất do master điều khiển. Các thiết bị slave chỉ phản hồi khi địa chỉ của chúng được gọi và hoàn toàn không chủ động chiếm quyền điều khiển bus. Do đó, trong mô hình HIL, việc mô phỏng nhiều thiết bị I2C có thể được thực hiện bằng cách quản lý logic xử lý địa chỉ ở mức phần mềm, thay vì cần nhiều ngoại vi I2C vật lý hoặc bit-banging phức tạp.

Với cách tiếp cận này, hệ thống HIL chỉ cần giám sát địa chỉ được DUT gửi ra, từ đó kích hoạt mô hình thiết bị tương ứng để phản hồi dữ liệu. Phương pháp này vừa đảm bảo tuân thủ nguyên lý hoạt động của giao thức I2C, vừa giữ được độ chính xác về thời gian và hiệu năng của hệ thống, phù hợp hơn cho các ứng dụng mô phỏng HIL trong kiểm thử thiết bị nhúng.

Trong hệ thống mô phỏng phần cứng trong vòng lặp này, I2C được dùng để mô phỏng EEPROM và RTC để hỗ trợ kiểm thử phần mềm của DUT.
\subsection{Giao thức SPI}
SPI (Serial Peripheral Interface) là giao thức truyền thông nối tiếp đồng bộ, hoạt động theo mô hình master–slave. Giao thức này sử dụng các đường tín hiệu chính bao gồm MOSI (Master Out Slave In), MISO (Master In Slave Out), SCK (Serial Clock) và CS (Chip Select). SPI cho phép truyền dữ liệu với tốc độ cao và có cấu trúc đơn giản, phù hợp với các thiết bị yêu cầu băng thông lớn.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{image/spi.png}
    \caption{Giao thức SPI}
    \label{fig:spi}
\end{figure}

Nguyên lý hoạt động của SPI dựa trên việc master kích hoạt tín hiệu CS của slave cần giao tiếp. Khi CS được kích hoạt, dữ liệu sẽ được truyền song công trên hai đường MOSI và MISO theo từng xung clock. Do không sử dụng cơ chế địa chỉ như I2C, mỗi thiết bị slave SPI thường cần một đường CS riêng để được lựa chọn.

Trong hệ thống mô phỏng phần cứng trong vòng lặp này, SPI được dùng để mô phỏng Flash để hỗ trợ kiểm thử phần mềm của DUT.
\subsection{Giao thức USB}
USB (Universal Serial Bus) là giao thức truyền thông nối tiếp tốc độ cao, được thiết kế để kết nối và trao đổi dữ liệu giữa thiết bị chủ (host) và các thiết bị ngoại vi (device). USB hoạt động theo mô hình host–device, trong đó host quản lý quá trình kết nối, cấu hình và truyền dữ liệu.

Nguyên lý hoạt động của USB dựa trên các giai đoạn như phát hiện thiết bị, cấp địa chỉ, cấu hình và trao đổi dữ liệu thông qua các endpoint. Dữ liệu USB được truyền theo các gói tin với cấu trúc chặt chẽ, đảm bảo tính toàn vẹn và độ tin cậy trong quá trình giao tiếp.

Trong hệ thống mô phỏng phần cứng trong vòng lặp này, USB được sử dụng làm kênh giao tiếp giữa hệ thống mô phỏng và máy tính, hệ thống và DUT. Thông qua USB, dữ liệu mô phỏng, trạng thái DUT và kết quả kiểm thử có thể được truyền lên phần mềm giám sát, đồng thời cho phép người dùng điều khiển và cấu hình quá trình mô phỏng một cách thuận tiện.
\subsection{Ngoại vi analog ADC/DAC}
ADC (Analog-to-Digital Converter) và DAC (Digital-to-Analog Converter) là các ngoại vi dùng để chuyển đổi giữa tín hiệu tương tự và tín hiệu số trong hệ thống nhúng. ADC chuyển đổi điện áp hoặc dòng điện tương tự thành giá trị số để vi điều khiển xử lý, trong khi DAC thực hiện quá trình ngược lại.

Nguyên lý hoạt động của ADC dựa trên việc lấy mẫu tín hiệu analog theo chu kỳ và lượng hóa thành giá trị số với độ phân giải xác định. DAC tạo ra tín hiệu analog bằng cách chuyển đổi các giá trị số thành mức điện áp tương ứng.

Trong hệ thống mô phỏng phần cứng trong vòng lặp này, ADC và DAC được sử dụng để mô phỏng các tín hiệu cảm biến và tín hiệu điều khiển analog. Việc mô phỏng này cho phép kiểm thử khả năng xử lý tín hiệu tương tự của DUT, đánh giá phản ứng của firmware trước các thay đổi liên tục của tín hiệu đầu vào và kiểm tra các thuật toán xử lý tín hiệu trong điều kiện gần với thực tế.

\section{Hệ điều hành thời gian thực (Real-time Operating System – RTOS)}
\subsection{Giới thiệu về RTOS}
Hệ điều hành thời gian thực (Real-time Operating System – RTOS) là hệ điều hành được thiết kế để xử lý các tác vụ đòi hỏi thời gian phản hồi chính xác và nhanh chóng, đặc biệt trong các ứng dụng như hệ thống nhúng. 
Khác với các hệ điều hành thông dụng như Windows, macOS hay Linux, vốn ưu tiên hiệu suất tổng thể và tính đa dụng, RTOS tập trung đảm bảo các tác vụ được thực hiện đúng thời hạn hoặc trong khoảng thời gian giới hạn. 
Với khả năng quản lý đa nhiệm hiệu quả, RTOS ưu tiên các tác vụ quan trọng thông qua cơ chế lập lịch, đồng thời giảm thiểu độ trễ để phản hồi nhanh các sự kiện hoặc ngắt. Hệ điều hành này thường nhẹ, sử dụng ít tài nguyên, phù hợp với các thiết bị có phần cứng hạn chế.

RTOS có thể được chia làm 2 loại dựa vào độ trễ:
\begin{itemize}[leftmargin=2.5cm]
    \item Thời gian thực cứng (hard real-time).
    \item Thời gian thực mềm (soft real-time).
\end{itemize}

Hard real-time là loại hệ điều hành yêu cầu các tác vụ phải được thực hiện chính xác trong khoảng thời gian quy định mà không có bất kỳ độ trễ nào. 
Vì việc không tuân thủ thời hạn (deadline) có thể dẫn đến những hậu quả nghiêm trọng cho hệ thống hoặc thậm chí gây nguy hiểm đến tính mạng con người. 
Ví dụ như hệ thống túi khí trên xe ô tô, nếu cảm biến va chạm phát hiện sự cố và kích hoạt túi khí trong khoảng thời gian cực ngắn, thường dưới 0,1 giây. 
Nếu hệ thống không đáp ứng được thời gian này, túi khí có thể không bung kịp, dẫn đến nguy cơ tai nạn nghiêm trọng cho người trên xe.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{image/hard_real_time.jpg}
    \caption{Đồ thị thời gian của Hard real-time}
    \label{fig:hard_real_time}
\end{figure}

Soft real-time là loại hệ điều hành được thiết kế để xử lý các tác vụ với yêu cầu thời gian linh hoạt hơn so với Hard Real-Time, nơi độ trễ nhỏ có thể được chấp nhận mà không gây ra hậu quả nghiêm trọng. 
Trong Soft Real-Time, các tác vụ vẫn cần được hoàn thành trong khoảng thời gian mong muốn, nhưng nếu thỉnh thoảng vượt quá thời hạn một chút, hệ thống vẫn hoạt động bình thường và không dẫn đến thiệt hại lớn. 
Đặc điểm này khiến Soft Real-Time phù hợp cho các ứng dụng ưu tiên hiệu suất nhưng không đòi hỏi tính chính xác tuyệt đối về thời gian. Tuy nhiên cần lưu ý, thời gian đáp ứng càng trễ thì thiệt hại càng lớn. 
Ví dụ như hệ thống tưới tiêu tự động, hệ thống được lập trình tưới nước vào những khung giờ cố định trong ngày. Nếu hệ thống bắt đầu tưới trễ hơn vài phút so với lịch trình, điều này thường không gây hại nghiêm trọng, cây vẫn nhận được nước và tiếp tục sinh trưởng bình thường. 
Tuy nhiên, nếu thời gian trễ kéo dài quá lâu, ví dụ hàng giờ, cây trồng có thể bị thiếu nước, dẫn đến nguy cơ héo úa hoặc chết dần.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{image/soft_real_time.jpg}
    \caption{Đồ thị thời gian của Soft real-time}
    \label{fig:soft_real_time}
\end{figure}

\subsection{Thread (Task) trong RTOS}
Trong hệ điều hành thời gian thực (RTOS), thread (hay còn gọi là task) là những tác vụ thực thi những nhiệm vụ riêng biệt. 
Trong các hệ thống nhúng đơn giản, mô hình \textbf{Super Loop} thường được sử dụng để điều khiển toàn bộ chương trình. 
Trong mô hình này, các tác vụ được thực hiện tuần tự theo một vòng lặp vô hạn, không có khái niệm ưu tiên hay xử lý đồng thời.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{image/superloop.jpg}
    \caption{Task trong Super Loop}
    \label{fig:superloop}
\end{figure}

Tuy nhiên, khi hệ thống phức tạp hơn, với nhiều task hơn, yêu cầu thời gian thực nghiêm ngặt hoặc xử lý những sự kiện bất đồng bộ thì \textbf{Super Loop} trở nên khó kiểm soát và thiếu hiệu quả. 
Lúc này, việc chuyển sang sử dụng \textbf{RTOS} sẽ giúp hệ thống có thể quản lý nhiều task độc lập, hỗ trợ ưu tiên, đa luồng, và đáp ứng thời gian thực một cách chính xác và linh hoạt hơn.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{image/task_RTOS.jpg}
    \caption{Task trong Super Loop}
    \label{fig:task_RTOS}
\end{figure}
Mỗi thread là một chương tình nhỏ. Nó có điểm bắt đầu và sau đó thường sẽ là một vòng lặp vô hạn và sẽ không trả về bất kỳ giá trị nào hết.
\begin{table}[H]
\centering
\begin{tabular}{|p{13cm}|}
\hline
\begin{lstlisting}[language=C,
                   basicstyle=\ttfamily\small,
                   aboveskip=0pt,
                   belowskip=0pt]
void display_thread(void *pvParameters)
{
    while (1)
    {
        // Code
    }
}
\end{lstlisting}
\\ \hline
\end{tabular}
\caption{Ví dụ đoạn chương trình của 1 thread}
\label{tab:display_thread}
\end{table}

Mỗi thread có thể sở hữu riêng tài nguyên như bộ nhớ stack, trạng thái thực thi. 
RTOS quản lý thread thông qua một bộ lập lịch \textbf{Scheduler}. 
Khi bộ lập lịch cần chuyển đổi thực thi từ thread A sang thread B, nó sẽ thực hiện một quá trình gọi là \textbf{context switch}. 
Trong quá trình này, toàn bộ trạng thái hiện thời của thread A bao gồm các giá trị trong thanh ghi sẽ được lưu vào stack riêng của thread A để đảm bảo rằng trạng thái này có thể được khôi phục chính xác sau này. 
Sau đó, bộ lập lịch nạp các giá trị thanh ghi đã được lưu từ trước của thread B vào CPU, khôi phục lại chính xác ngữ cảnh của thread B tại thời điểm nó bị tạm dừng. 
Đặc biệt, thanh ghi bộ đếm chương trình (PC) sẽ xác định vị trí tiếp theo trong mã nguồn mà thread B sẽ tiếp tục thực thi. 
Nhờ vào cơ chế này, các thread trong hệ thống có thể được chuyển đổi qua lại một cách liền mạch và nhất quán, đảm bảo tính đồng thời và đáp ứng thời gian thực trong hệ điều hành. 
\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\textwidth]{image/thread_overview.jpg}
    \caption{Tổng quan thread}
    \label{fig:thread_overview}
\end{figure}

\noindent
Trong quá trình thực thi, mỗi tác vụ sẽ có những trạng thái chính sau:

\begin{itemize}
    \item \textbf{Ready:} Tác vụ đã sẵn sàng để thực thi nhưng một tác vụ có mức độ ưu tiên bằng hoặc cao hơn đang chạy.
    
    \item \textbf{Running:} Tác vụ đang được thực thi.
    
    \item \textbf{Blocked:} Tác vụ đang chờ một số sự kiện:
    \begin{itemize}
        \item \textbf{Time:} Nếu một tác vụ gọi \texttt{vTaskDelay()} thì nó sẽ bị chặn cho đến khi hết thời gian delay.
        \item \textbf{Resource:} Các tác vụ cũng có thể chặn chờ queue và semaphore…
    \end{itemize}

    \item \textbf{Suspended:} Giống với Block, nhưng không chờ sự kiện. Các tác vụ sẽ chỉ được chạy hoặc ngưng trạng thái bị treo khi được gọi thông qua API \texttt{vTaskSuspend()} và \texttt{vTaskResume()} tương ứng.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.65\textwidth]{image/thread_state.jpg}
    \caption{Trạng thái của thread}
    \label{fig:thread_state}
\end{figure}

\subsection{Bộ lập lịch (Scheduler)}
Bộ lập lịch (\textbf{Scheduler}) là một thành phần quan trọng trong hệ điều hành thời gian thực hoặc các hệ điều hành khác, chịu trách nhiệm quyết định thứ tự và thời điểm các thread hoặc task được thực thi trên bộ xử lý. 
Bộ lập lịch phân bổ tài nguyên CPU dựa trên các yếu tố như mức độ ưu tiên, thời hạn (deadline), hoặc thuật toán lập lịch. 
Trong RTOS, scheduler đảm bảo các tác vụ thời gian thực, đặc biệt là Hard Real-Time, được xử lý đúng hạn bằng cách thực hiện \textbf{context switch}.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{image/multi_task.jpg}
    \caption{Thực tế hoạt động của Multi-Task trong RTOS}
    \label{fig:multi_task}
\end{figure}
Nhờ có bộ lập lịch, chúng ta có thể kiểm soát việc thực thi các tác vụ một cách linh hoạt và hiệu quả. Bộ lập lịch đảm bảo rằng mỗi task được thực hiện đúng thời điểm, không bị bỏ sót, ngay cả khi hệ thống có nhiều tác vụ cùng lúc. Mặc dù trên vi điều khiển chỉ có một lõi xử lý, nhờ cơ chế chuyển đổi nhanh giữa các tác vụ, hệ thống có thể tạo ra cảm giác như các tác vụ đang chạy song song.

Để thực hiện được điều này, RTOS sử dụng các thuật toán lập lịch nhằm xác định thứ tự và thời điểm mà mỗi task được phép truy cập CPU. Mỗi thuật toán sẽ có nguyên lý hoạt động, ưu điểm và hạn chế riêng, từ đó ảnh hưởng trực tiếp đến độ trễ, hiệu năng và tính đáp ứng thời gian thực của hệ thống. Một số thuật toán phổ biến có thể kể đến như \textbf{Round Robin}, \textbf{Preemptive Scheduling} và \textbf{Cooperative Scheduling}.

\textbf{Round Robin} là một thuật toán lập lịch đơn giản, trong đó mỗi thread được cấp CPU trong một khoảng thời gian thực thi giới hạn được gọi là \textbf{time slice}. Khi time slice hết, task hiện tại bị tạm dừng và đưa vào trạng thái \texttt{BLOCKED} và nhường CPU cho các thread khác ở trạng thái \texttt{READY} trong hàng đợi bắt đầu chạy. Thuật toán này sẽ cho các thread đều có cơ hội được thực thi và lặp lại theo vòng tròn.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{image/round_robin.jpg}
    \caption{Thuật toán lập lịch Round Robin}
    \label{fig:round_robin}
\end{figure}

\textbf{Preemptive Scheduling} là thuật toán khá tương đồng với \textbf{Round Robin}, các thread sẽ được CPU chạy trong khoảng thời gian giới hạn. Tuy nhiên \textbf{Preemptive Scheduling} sẽ cho phép các thread có những mức độ ưu tiên khác nhau. Các thread có mức độ ưu tiên cao hơn trong trạng thái \texttt{READY} có thể chiếm quyền CPU của thread đang thực thi ngay lập tức và đưa thread đó vào trạng thái \texttt{BLOCKED}. Điều này cho phép hệ thống phản hồi một cách nhanh chóng khi có sự kiện quan trọng. Nếu các thread có cùng mức độ ưu tiên thì Scheduler sẽ dùng thuật toán Round Robin. Nhược điểm của thuật toán này là nếu các thread có mức ưu tiên cao hơn luôn được chạy thì các thread có mức ưu tiên thấp hơn có thể sẽ bị “đói” (starvation).
\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{image/preemptive.jpg}
    \caption{Thuật toán lập lịch Preemptive Scheduling}
    \label{fig:preemptive}
\end{figure}

\textbf{Cooperative Scheduling} là thuật toán cho phép các thread được thực thi đến khi nó chủ động nhường CPU bằng cách gọi \texttt{yield()} hoặc \texttt{suspend()}.  Điều này sẽ giúp cho các thread không bị gián đoạn bởi các thread khác. Tuy nhiên các thread cần được quản lý tốt vì thuật toán này có thể cho phép một thread thực thi quá lâu dẫn đến các thread khác rơi vào tình trạng “đói”.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{image/cooperative.jpg}
    \caption{Thuật toán lập lịch Cooperative Scheduling}
    \label{fig:cooperative}
\end{figure}

\subsection{Queue (hàng đợi)}
Queue (hàng đợi) trong hệ điều hành thời gian thực (RTOS) là một cơ chế dữ liệu được sử dụng để truyền thông giữa các thread hoặc task một cách an toàn và có tổ chức. Queue hoạt động theo nguyên tắc FIFO (First In, First Out), nghĩa là phần tử được thêm vào đầu tiên sẽ được xử lý đầu tiên. Trong RTOS, queue thường được dùng để truyền thông điệp, dữ liệu hoặc tín hiệu giữa các task, chẳng hạn như gửi thông tin từ một task đọc cảm biến đến task điều khiển trong hệ thống nhúng. Cơ chế này giúp đồng bộ hóa và tránh xung đột tài nguyên, với các thao tác như \texttt{enqueue} (thêm phần tử) và \texttt{dequeue} (lấy phần tử) được quản lý bởi RTOS để đảm bảo tính chính xác và thời gian thực
\begin{figure}[H]
    \centering
    \begin{minipage}{0.48\textwidth}
        \centering
        \captionsetup{width=6cm, justification=centering}
        \includegraphics[width=\textwidth]{image/enqueue.jpg}
        \vspace{1pt}
        \caption{Thêm phần tử vào queue (enqueue)}
        \label{fig:enqueue}
    \end{minipage}
    \hfill
    \begin{minipage}{0.48\textwidth}
        \vspace{-8pt}
        \centering
        \captionsetup{width=6cm, justification=centering}
        \includegraphics[width=\textwidth]{image/dequeue.jpg}
        \caption{Lấy phần tử từ queue (dequeue)}
        \label{fig:dequeue}
    \end{minipage}
\end{figure}
\subsection{Semaphore và Mutex}
\textbf{Semaphore} trong hệ điều hành thời gian thực (RTOS) là một cơ chế đồng bộ hóa dùng để kiểm soát truy cập vào các tài nguyên chung hoặc quản lý giao tiếp giữa các thread. Semaphore có thể là \textbf{binary semaphore} chỉ có hai trạng thái 0 hoặc 1 tương tự như khóa hoặc \textbf{counting semaphore} cho phép quản lý nhiều tài nguyên với giá trị đếm lớn hơn. Ví dụ nếu có 1 tài nguyên như buffer và có 3 task có thể truy cập vào buffer đó, counting semaphore lúc này được khởi tạo giá trị là 2 thì semaphore sẽ như 2 chiếc “chìa khóa”, thread nào lấy được sẽ được phép truy cập
\begin{figure}[H]
    \centering
    \includegraphics[width=0.75\textwidth]{image/couting_sem.jpg}
    \caption{Couting Semaphore}
    \label{fig:couting_sem}
\end{figure}
\textbf{Mutex} hoạt động tương tự \textbf{binary semaphore}, là một cơ chế đồng bộ dùng để bảo vệ vùng tài nguyên dùng chung, đảm bảo rằng chỉ một thread được phép truy cập tài nguyên đó tại một thời điểm. 
Tuy nhiên \textbf{binary semaphore} không có tính sở hữu tức bất kì thread nào cũng đều có thể give (giải phóng) semphore. Đối với mutex, chỉ có một thread được sở hữu tại một thời điểm và chỉ có thread đó mới có thể giải phóng được mutex. 
Đồng thời mutex có tính \textbf{priority inheritance}, tức là nếu thread có mức ưu tiên thấp giữ mutex và thread có mức ưu tiên cao đang chờ thì RTOS sẽ tạm thời nâng mức ưu tiên của thread thấp lên bằng thread cao. 
Điều này giúp tránh hiện tượng \textbf{priority inheritance}, khi thread cao đang đợi semaphore của thread thấp mà có một thread có mức ưu tiên trung bình \texttt{READY} dẫn đến thread thấp không giải phóng được semaphore.

Việc sử dụng semaphore đôi khi có thể dẫn đến tình trạng nhiều thread chờ đợi vô thời hạn để nhận được một semaphore. Tuy nhiên semaphore đó lại chỉ có thể được giải phóng bởi chính một trong các thread bị chặn. Điều này tạo ra một vòng lặp phụ thuộc lẫn nhau khiến tất cả các thread đều bị treo và không thể tiếp tục thực thi, tình trạng này được gọi là deadlock. Điều này tương tự với mutex.

Ví dụ:
\begin{itemize}[leftmargin=2.5cm, label=\textendash]
    \item \texttt{thread\_1} giữ mutex A và đợi mutex B.
    \item \texttt{thread\_2} giữ mutex B và đợi mutex A.
\end{itemize}
